---
title: Knowledge Integration in Language Models
date: 2023/04/23
category:
- NLP
tags:
- NLP
toc: true
---

# 들어가며 *Intro*
최근 OpenAI의 ChatGPT로부터 시작된 언어모형에 대한 관심이 뜨겁습니다. 마치 알파고와 이세돌 9단 사이의 바둑 대국 이후에 일어났던 인공지능 분야에 대한 관심이 재현된 것만 같네요. ChatGPT가 이러한 뜨거운 관심을 받고 있는 이유는, 마치 사람과도 같은 자연스러운 문장을 생성할 수 있을 뿐만 아니라, 일반적인 질의 응답을 넘어서 간단한 추론, 연산, 프로그래밍 등의 같은 다양한 작업들을 수행할 수 있기 때문으로 보입니다. 그러나 ChatGPT에도 여전히 극복해야할 다양한 문제점들이 남아있으며, 대표적인 과제 중 하나는 바로 언어 모형의 신뢰성*Reliability*에 대한 부분입니다. 이 글에서는 언어 모형이 사실에 기반하지 않은 내용을 마치 사실처럼 지어내는 환각 현상*Hallucination*에 대해 알아보고, 이를 완화하기 위해 어떤 방법들이 연구되어 왔는지 간단하게 리뷰해보도록 하겠습니다.

# 언어 모형의 환각 현상 *Hallucination of Language Models*
보다 신뢰할만한 답변을 생성하기 위해서, 언어 모형은 1) 사실 정보를 알고 있어야 하며, 2) 이에 기반하여 답변을 생성할 수 있어야 합니다. 여기에서는 Petroni et al. (EMNLP 2019)이 대표적인 언어 모형들 중 하나인 BERT-Large의 답변을 분석한 결과를 통해, 언어 모형이 무엇을 알고 있는지, 잘못된 답변을 한다면 그 이유는 무엇인지에 대해 살펴보도록 하겠습니다. 매우 유명한 언어 모형 중 하나인 BERT는 해당 논문에서 주어진 컨텍스트에 대해 다음과 같은 단어를 예측했습니다.

- iPod Touch is produced by `Apple`.
- London Jazz Festival is located in `London`.
- Dani Alves plays with `Santos`.
- Carl III used to communicate in `German`.
- Ravens can `fly`.

제시된 예시 중에서 1, 2, 5번에서는 정확한 단어를 3, 4번에서는 잘못된 단어를 생성한 것을 확인할 수 있습니다. 기본적으로, 현재의 기준에서 보면 그리 크지않은 (cf. BERT-Large (345M) vs. PaLM (540B), GPT3 (175B), LLaMa(65B), etc.) 언어 모형임에도 불구하고 별도의 Fine-tuning 과정 없이도 정답을 꽤 잘 맞춘다는 점이 인상 깊습니다. 우리가 조금 더 주목할만한 부분은, 틀린 답변을 하는 경우에도 꽤 그럴듯한 단어를 선택한다는 점입니다. 예를 들어, 세번째 문장에서 Dani Alves는 Barcelona 소속의 축구선수이므로 정답은 Barcelona가 되어야 합니다. BERT가 예측한 Santos는 정답은 아니지만 축구팀 중 하나이므로, 문장 자체만 놓고 본다면 그럴듯한 문장이 되죠. 네번째 문장에서 등장하는 Carl 3세는 19세기 초 스웨덴과 노르웨이를 통치했던 군주로, 독일어가 아닌 스웨덴어를 사용했습니다. 하지만 독일어와 스웨덴어 모두 언어의 일종이므로, 앞선 예시와 마찬가지로 의미 상으로는 문제가 없는 문장이 된다는 점을 살펴볼 수 있습니다.

사실에 근거하지 않은 이러한 답변들이 생성되는 이유는 무엇일까요? Petroni et al.은 다음과 같은 세 가지 항목을 원인으로 제시합니다.

1. 훈련 과정에서 학습한 적 없는 사실
2. 희귀한 사건
3. 언어 모형의 단어 민감성

다음 절에서는 이러한 Hallucination 문제를 해결하기 위해, 즉, 1) 언어 모형에 지식을 통합하고, 2) 언어 모형이 통합된 지식을예측에 적극적으로 활용하도록 하기 위한 다양한 방법들에 대해 살펴보도록 하겠습니다.

# 언어 모형에 지식을 통합하기 위한 방안 *Integration of Knowledge in LM*
이번 절에서는 연구되었던 방법들을 크게 세 가지 방법론으로 분류하여 살펴보도록 하겠습니다. 각각의 방법론은 1) 사전 학습된 개체 임베딩의 추가, 2) 외부 메모리의 사용, 3) 학습 데이터에 대한 수정입니다.

### 사전 학습된 개체 임베딩의 추가 *Adding Pre-trained Entity Embeddings*
![](https://i.imgur.com/s0vSRPu.jpg)
가장 먼저 살펴볼 모형은 ERNIE (Zhang et al., ACL 2019) 입니다. ERNIE는 기본적으로 지식*Knowledge*이 여러 개체들*Entities* 사이의 관계*Relation*로 표현될 수 있다는 생각에 기반합니다. 예를 들어, ‘Dani Alves’와 ‘소속 팀 관계’에 있는 것은 ‘FC Barcelona’이고, ‘Carl 3세’와 ‘모국어 관계’에 있는 언어는 ‘스웨덴어’라고 할 수 있습니다. 이에 따라, ERNIE는 언어 모형이 언어를 학습함에 있어서 단어에 대한 정보 뿐만 아니라, 단어가 가리키고 있는 개체*Entity*에 대한 정보를 함께 학습함으로써 지식을 언어 모형에 통합할 수 있다고 주장합니다. 그리고 단어가 전달하는 정보들이 단어 임베딩*Word Embedding*을 통해 수치 벡터로 표현되는 것처럼, 개체에 대한 정보를 담고 있는 개체 임베딩*Entity Embedding*을 ERNIE의 학습과정에서 활용하고자 합니다. 단어의 의미를 벡터 공간에 나타내기 위한 많은 노력들(e.g., Word2Vec, BERT)이 있었던 것과 유사하게, 이러한 개체*Entity*와 관계*Relation*를 벡터 공간 상의 위치시킴으로써 수치로 표현하기 위한 다양한 방법들이 개발되어 왔습니다. 대표적으로 TransE, Wikipedia2Vec, BLINK와 같은 방법들이 있지만, 이 글에서는 자세히 다루지 않습니다. 다만 ERNIE는 개체 임베딩을 생성하는 방법 자체에 대해서는 Agnostic한 모형이므로, 어떤 개체 임베딩이라도 사용할 수 있다는 특징이 있다는 점에 대해서는 주목할 필요가 있습니다.

그러나 훈련 과정에서 단어 임베딩과 개체 임베딩을 동시에 사용하는 데에는 문제가 하나 있습니다. 바로 두 임베딩이 정의된 벡터 공간이 서로 다르다는 점입니다. 다시 말해, 해당 임베딩들은 일반적으로 서로 독립적으로 학습된 벡터들이므로, 특정 벡터가 각 공간에서 지니는 의미가 전혀 다를 수 있다는 점입니다. 예를 들어, 단어 임베딩은 768 차원에서 정의되고, 개체 임베딩은 128 차원에서 정의되는 것처럼 두 임베딩이 정의되는 차원 자체가 아예 다를 수도 있습니다. 따라서, 각각의 임베딩을 두 임베딩이 함께 사용될 수 있는 새로운 벡터 공간으로 맵핑시켜주는 과정이 필요한데, 해당 논문에서는 이러한 과정을 Fusion이라고 부르고 있습니다. 이러한 Fusion은 각각의 임베딩에 Fusion Matrix를 곱해줌으로써 이루어지며, 해당 Matrix 또한 학습을 통해 최적화되는 파라미터입니다.

마지막으로, ERNIE에서는 언어 모형이 추가된 개체 임베딩을 훈련 과정에서 보다 적극적으로 활용하도록 하기 위해, 각각의 Input token이 어떤 개체를 가리키는지 예측하는 Task를 훈련 과정에 추가하였습니다. denoising Entity Autoencoding (dEA)라고 불리는 해당 Task는 Vincent et al. (2008)에 의해 처음 제안되었으며, 기존의 BERT의 Loss에 $\mathcal{L}\_{dEA}$가 추가된 ERNIE의 최종 Loss는 다음과 같은 형태가 됩니다.

$$ \mathcal{L}\_{ERNIE} = \mathcal{L}\_{MLM} + \mathcal{L}\_{NSP} + \mathcal{L}\_{dEA}$$

### 외부 메모리의 사용 *Using an External Memory*
다음으로 살펴볼 방법은 External Memory를 활용하는 방법입니다. Khandelwal et al. (2020)이 제안한 KNN-LM은 언어 모형의 단어 민감성에 주목합니다. 오답을 생성했던 언어 모형은, 질문에 사용된 단어를 약간만 다르게 변경해줘도 정답을 맞추는 경우가 많습니다. 예를 들어, 언어 모형이 의미론적으로 유사한 세 문장에 대해 다음과 같은 결과를 생성하는 경우에 대해 생각해보겠습니다.

- Carl III used to communicate in `German`.
- Carl III used to speak in `Swedish`.
- Carl III’s mother tongue was `Swedish`.

첫 번째 문장에서는 언어 모형이 정답을 맞추지 못했지만, 두번째와 세번째 문장에서는 올바른 단어를 예측한 것을 확인할 수 있습니다. 그렇다면 다음 토큰을 예측할 때에, 주어진 문장과 의미론적으로 유사한 다른 문장들의 예측 결과를 활용하면 예측의 안정성을 향상시킬 수 있지 않을까요? 원 논문의 다이어그램을 보면서 조금 더 자세히 살펴보도록 하겠습니다.

![](https://i.imgur.com/Qgo0b8w.jpg)

상단의 다이어그램에서 우리는 ‘Shakespeare’s play `____`’라는 문장에서 빈칸에 해당하는 단어를 예측하고자 합니다. 해당 문장만 가지고 예측을 수행할 경우 빈칸에 해당할 확률이 가장 높은 단어는 0.2의 확률을 지니는 Hamlet 이라는 것을 알 수 있습니다. 반면, 앞서 언급했던 것처럼 KNN-LM은 해당 문장과 의미론적으로 유사한 문장들의 예측 결과를 추가적으로 활용하고자 했습니다. 기본적으로 KNN-LM은 KNN을 활용하여 얻은 예측 결과와 LM을 통해 얻은 예측 결과를 통합하는 형태로 구성되어 있는데, 이러한 답변 생성은 다음과 같은 절차를 통해 이루어집니다.

우선, KNN-LM은 예측하고자 하는 문장과 유사한 k개의 문장들을 사전에 구축된 Datastore에서 검색합니다. 문장들 간의 유사도는 각 문장의 Vector representation에 다양한 Distance/Similarity Measure를 적용하여 계산할 수 있습니다. 상단의 예시에서는 ‘Shakespear authored `____`’, ‘Shakespeare wrote `____`’, ‘The Bard’s famous play `____`’의 세 문장이 각각 Distance 3, 4, 5를 지니는 유사 문장으로 선별된 것을 확인할 수 있습니다. 다음으로, KNN-LM은 유사한 문장들 다음에 왔던 단어들에 대해 살펴보고, 이를 종합하여 KNN에 의한 토큰 선택 확률을 계산합니다. Hamlet이 가장 높은 확률로 예측되었던 LM에 의해 예측과는 다르게, KNN을 통한 예측에서는 Macbeth가 0.8의 높은 확률을 지니는 다음 단어로 예측된 것을 확인해 볼 수 있습니다. 마지막으로, KNN-LM의 최종 예측은 Macbeth, Hamlet이 각각 0.8, 0.2의 확률을 지녔던 KNN 파트의 예측과 0.1, 0.2의 확률을 보였던 LM 파트의 예측 결과를 Interpolation 하는 형태로 수행됩니다. 주어진 다이어그램에서는 Macbeth가 0.7, Hamlet이 0.2의 최종 확률을 지님으로써, Hamlet이 선정되었던 기존의 LM의 결과와는 다르게 Macbeth가 선택되는 결과를 보여주고 있습니다.

### 학습 데이터에 대한 수정 *Modifying the Training Data*

Xiong et al. (ICLR 2020)은 언어 모형이 올바른 지식과 잘못된 지식을 명시적으로 훈련받은 적이 없다는 사실에 주목합니다. 예를 들어, 언어 모형의 훈련 데이터에 ‘Dani Alves has played in FC Barcelona.’라는 문장이 포함되어 있었다고 생각해보겠습니다. 물론 언어 모형은 해당 문장을 통해 Barcelona라는 단어가 선택될 확률이 높아지도록 학습을 진행하지만, Santos라는 단어로 예측을 하면 안된다는 점을 명시적으로 학습하지는 않습니다. 언어 모형에게 의도적으로 ‘오답’을 보여주고, 해당 오답을 선택하지 않도록 명시적으로 학습을 진행하면 모형이 오답률을 낮출 수 있지 않을까요? 이러한 가정에 따라, 해당 논문에서는 학습 데이터셋 자체를 의도적으로 오염*corrupted*시키고, 언어 모형이 학습을 진행할 때 해당 단어가 잘못된 정보로 오염된 단어인지 아닌지 예측하는 Task를 추가한 모형인 WKLM*Weakly Supervised Knowledge-Pretrained Language Model*을 제안합니다. WKLM에서 추가된 이진 분류 Task에 대한 성능은 Entity Replacement Loss $\mathcal{L}\_{ER}$에 따라 평가되며, 이에 따라 WKLM의 최종 Loss는 다음과 같은 형태가 됩니다.

$$ \mathcal{L}\_{WKLM} = \mathcal{L}\_{MLM} + \mathcal{L}\_{ER} $$

# 마치며 *Outro*
이번 글에서는 언어 모형의 Hallucination 현상을 완화하기 위한 다양한 방법들에 대해 살펴보았습니다. 언어 모형의 신뢰성 향상은 현재도 활발히 연구되고 있는 분야입니다. 기회가 된다면 다음에는 OpenAI의 RETRO (Borgeaud et al, 2021) 등 상대적으로 최근에 제안된 방법론들에 대해 살펴보도록 하겠습니다.